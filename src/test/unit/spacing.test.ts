import * as assert from 'assert';
import { getShortcodeContext } from '../../shortcode-utils';

describe('Spacing behavior', () => {
  describe('needsLeadingSpace', () => {
    it('is true when no space after shortcode name', () => {
      // {{<fa|>}} - no space after "fa"
      const result = getShortcodeContext('{{<fa>}}', 5, 'fa');
      // This won't match because marker is "{{< fa" with space
      assert.strictEqual(result, null);
    });

    it('is false when space after shortcode name and content exists', () => {
      // {{< fa icon|>}} - space after "fa", content exists
      const result = getShortcodeContext('{{< fa icon >}}', 11, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.needsLeadingSpace, false);
    });

    it('is false when space after shortcode name and no content', () => {
      // {{< fa | >}} - space after "fa", cursor after space
      const result = getShortcodeContext('{{< fa  >}}', 7, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.needsLeadingSpace, false);
    });

    it('is true when no space after name and content is empty', () => {
      // This tests the marker without following space - but our marker includes space
      // so this case doesn't apply with standard shortcode format
      // The needsLeadingSpace is determined by whether there's content after marker
      const result = getShortcodeContext('{{< fa>}}', 6, 'fa');
      assert.ok(result !== null);
      // Content before cursor is empty, no space after marker
      assert.strictEqual(result!.needsLeadingSpace, true);
    });
  });

  describe('hasSpaceBeforeEnd', () => {
    it('is false when cursor directly before >}}', () => {
      // {{< fa icon|>}}
      const result = getShortcodeContext('{{< fa icon>}}', 11, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.hasSpaceBeforeEnd, false);
    });

    it('is true when space between cursor and >}}', () => {
      // {{< fa icon| >}}
      const result = getShortcodeContext('{{< fa icon >}}', 11, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.hasSpaceBeforeEnd, true);
    });

    it('is true with multiple spaces before end', () => {
      // {{< fa icon|   >}}
      const result = getShortcodeContext('{{< fa icon   >}}', 11, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.hasSpaceBeforeEnd, true);
    });

    it('is true when space before end even with text between cursor and end', () => {
      // {{< fa ic|on >}} - cursor mid-word, but there's still space before >}}
      const result = getShortcodeContext('{{< fa icon >}}', 9, 'fa');
      assert.ok(result !== null);
      // "on >}}" is after cursor, text before >}} is "on " which ends with space
      assert.strictEqual(result!.hasSpaceBeforeEnd, true);
    });

    it('is false when no space between text and end', () => {
      // {{< fa ic|on>}} - cursor mid-word, no space before >}}
      const result = getShortcodeContext('{{< fa icon>}}', 9, 'fa');
      assert.ok(result !== null);
      // "on>}}" is after cursor, text before >}} is "on" which doesn't end with space
      assert.strictEqual(result!.hasSpaceBeforeEnd, false);
    });
  });

  describe('combined spacing scenarios', () => {
    it('empty shortcode with spaces: {{< fa | >}}', () => {
      const result = getShortcodeContext('{{< fa  >}}', 7, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.needsLeadingSpace, false);
      assert.strictEqual(result!.hasSpaceBeforeEnd, true);
    });

    it('content no trailing space: {{< fa icon|>}}', () => {
      const result = getShortcodeContext('{{< fa icon>}}', 11, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.needsLeadingSpace, false);
      assert.strictEqual(result!.hasSpaceBeforeEnd, false);
    });

    it('content with trailing space: {{< fa icon| >}}', () => {
      const result = getShortcodeContext('{{< fa icon >}}', 11, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.needsLeadingSpace, false);
      assert.strictEqual(result!.hasSpaceBeforeEnd, true);
    });

    it('minimal spacing: {{< fa|>}}', () => {
      const result = getShortcodeContext('{{< fa>}}', 6, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.needsLeadingSpace, true);
      assert.strictEqual(result!.hasSpaceBeforeEnd, false);
    });
  });
});

describe('Insert text spacing application', () => {
  // These tests verify the expected behavior documented in the plan
  // The actual insert text is generated by completion functions using context values

  describe('leading space scenarios', () => {
    it('documents that needsLeadingSpace=true means insert text should start with space', () => {
      // When needsLeadingSpace is true, completion functions should prepend a space
      // This is a documentation test - the actual logic is in createAttributeNameCompletions etc.
      const result = getShortcodeContext('{{< fa>}}', 6, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.needsLeadingSpace, true);
      // The completion function would use: `${context.needsLeadingSpace ? ' ' : ''}${value}`
    });

    it('documents that needsLeadingSpace=false means no leading space needed', () => {
      const result = getShortcodeContext('{{< fa icon >}}', 11, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.needsLeadingSpace, false);
    });
  });

  describe('trailing space scenarios', () => {
    it('documents that hasSpaceBeforeEnd=false means insert text should end with space', () => {
      // When hasSpaceBeforeEnd is false, completions should append a space
      const result = getShortcodeContext('{{< fa icon>}}', 11, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.hasSpaceBeforeEnd, false);
      // The completion function would use: `${value}${context.hasSpaceBeforeEnd ? '' : ' '}`
    });

    it('documents that hasSpaceBeforeEnd=true means no trailing space needed', () => {
      const result = getShortcodeContext('{{< fa icon >}}', 11, 'fa');
      assert.ok(result !== null);
      assert.strictEqual(result!.hasSpaceBeforeEnd, true);
    });
  });
});
